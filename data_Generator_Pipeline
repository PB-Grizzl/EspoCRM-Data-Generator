"""
EspoCRM Synthetic Data Generator
Complete pipeline: Extract Schema -> Generate Data via OpenRouter -> Insert into EspoCRM
Uses ESPOCRM admin username/password for all operations

Set record counts and batch sizes at the top of main()
Occasionally prompt may miscreate some data points that are not formatted correcrly and thus not added,
just rerun script again if more data is needed
"""

import requests
import json
from typing import Dict, List, Optional
import time
import re
import math

class EspoCRMDataGenerator:
    
    def __init__(self, espocrm_url: str, username: str, password: str, openrouter_api_key: str,
                 generation_batch_size: int = 100, max_retries: int = 3):
        """
        Initialize the data generator
        
        Args:
            espocrm_url: EspoCRM base URL (e.g., http://localhost:8080)
            username: Admin username
            password: Admin password
            openrouter_api_key: OpenRouter API Key
            generation_batch_size: Max records to generate per API call (default: 100)
            max_retries: Max retry attempts for failed generations (default: 3)
        """
        self.espocrm_url = espocrm_url.rstrip('/')
        self.espocrm_api_url = f"{self.espocrm_url}/api/v1"
        self.openrouter_api_key = openrouter_api_key
        self.generation_batch_size = generation_batch_size
        self.max_retries = max_retries
        
        # Use Basic Auth with admin credentials for all EspoCRM operations
        self.espocrm_session = requests.Session()
        self.espocrm_session.auth = (username, password)
        self.espocrm_session.headers.update({'Content-Type': 'application/json'})
    
    def get_metadata(self) -> Optional[Dict]:
        """
        Get complete metadata from EspoCRM
        
        Returns:
            dict: Metadata object
        """
        try:
            response = self.espocrm_session.get(f"{self.espocrm_api_url}/Metadata")
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"  âœ— Metadata request failed: {response.status_code}")
                return None
                
        except Exception as e:
            print(f"  âœ— Error fetching metadata: {e}")
            return None
    
    def extract_entity_schema(self, entity_type: str, metadata: Dict) -> Dict:
        """
        Extract schema for a specific entity from metadata
        
        Args:
            entity_type: Entity type name
            metadata: Full metadata object
            
        Returns:
            dict: Entity schema
        """
        entity_defs = metadata.get('entityDefs', {}).get(entity_type, {})
        
        if not entity_defs:
            return {}
        
        fields_def = entity_defs.get('fields', {})
        links_def = entity_defs.get('links', {})
        
        schema = {}
        
        for field_name, field_info in fields_def.items():
            # Skip system/readonly/disabled fields
            if (field_info.get('readOnly') or 
                field_info.get('notStorable') or 
                field_info.get('disabled')):
                continue
            
            field_schema = {
                'type': field_info.get('type', 'string'),
                'required': field_info.get('required', False)
            }
            
            # Add field-specific metadata
            if 'options' in field_info:
                field_schema['options'] = field_info['options']
            
            if 'maxLength' in field_info:
                field_schema['maxLength'] = field_info['maxLength']
            
            if 'min' in field_info:
                field_schema['min'] = field_info['min']
            
            if 'max' in field_info:
                field_schema['max'] = field_info['max']
            
            if 'default' in field_info:
                field_schema['default'] = field_info['default']
            
            # Handle link fields
            if field_info.get('type') in ['link', 'linkMultiple', 'linkParent']:
                link_info = links_def.get(field_name, {})
                if 'entity' in link_info:
                    field_schema['references'] = link_info['entity']
            
            schema[field_name] = field_schema
        
        return schema
    
    def get_entity_schema(self, entity_type: str) -> Dict:
        """
        Get schema for a specific entity type (dynamically extracted)
        
        Args:
            entity_type: Entity type (Account, Contact, Lead, Opportunity)
            
        Returns:
            dict: Entity schema
        """
        if not hasattr(self, '_cached_metadata'):
            print("  ðŸ” Fetching metadata from EspoCRM...")
            self._cached_metadata = self.get_metadata()
            if self._cached_metadata:
                print("  âœ“ Metadata retrieved")
            else:
                print("  âœ— Failed to get metadata, using fallback")
                self._cached_metadata = None
        
        if self._cached_metadata:
            schema = self.extract_entity_schema(entity_type, self._cached_metadata)
            if schema:
                return schema
        
        # Fallback to basic schema if metadata extraction fails
        print(f"  âš  Using fallback schema for {entity_type}")
        return self._get_fallback_schema(entity_type)
    
    def _get_fallback_schema(self, entity_type: str) -> Dict:
        """Fallback schemas if metadata extraction fails"""
        fallback = {
            'Account': {
                'name': {'type': 'varchar', 'required': True},
                'emailAddress': {'type': 'varchar'},
                'phoneNumber': {'type': 'varchar'},
                'type': {'type': 'enum', 'options': ['Customer', 'Investor', 'Partner', 'Reseller']},
            },
            'Contact': {
                'firstName': {'type': 'varchar', 'required': True}, 
                'lastName': {'type': 'varchar', 'required': True},
                'emailAddress': {'type': 'varchar'},
                'phoneNumber': {'type': 'varchar'},
            },
            'Lead': {
                'firstName': {'type': 'varchar', 'required': True}, 
                'lastName': {'type': 'varchar', 'required': True},
                'status': {'type': 'enum', 'options': ['New', 'Assigned', 'In Process']},
            },
            'Opportunity': {
                'name': {'type': 'varchar', 'required': True}, 
                'amount': {'type': 'currency', 'required': True},
                'stage': {'type': 'enum', 'options': ['Prospecting', 'Qualification', 'Proposal']},
            }
        }
        return fallback.get(entity_type, {})
    
    def get_account_by_id(self, account_id: str) -> Optional[Dict]:
        """Fetch a single account by ID"""
        try:
            response = self.espocrm_session.get(f"{self.espocrm_api_url}/Account/{account_id}")
            if response.status_code == 200:
                return response.json()
            return None
        except Exception as e:
            return None
    
    def fetch_accounts_data(self, account_ids: List[str]) -> Dict[str, Dict]:
        """Fetch account data for all provided IDs"""
        print(f"  ðŸ“¥ Fetching data for {len(account_ids)} accounts...")
        accounts_map = {}
        for account_id in account_ids:
            account_data = self.get_account_by_id(account_id)
            if account_data:
                accounts_map[account_id] = account_data
        print(f"  âœ“ Fetched {len(accounts_map)} account records")
        return accounts_map
    
    def derive_email_domain(self, company_name: str) -> str:
        """Derive an email domain from a company name"""
        name = company_name.lower()
        for suffix in [' inc', ' inc.', ' corp', ' corp.', ' corporation', ' llc', ' ltd', ' ltd.', 
                       ' limited', ' company', ' co', ' co.', ' group', ' partners', ' systems',
                       ' technologies', ' solutions', ' services', ' enterprises', ' international']:
            name = name.replace(suffix, '')
        name = re.sub(r'[^a-z0-9]', '', name)
        return f"{name}.com"
    def extract_json_from_response(self, content: str) -> Optional[List[Dict]]:
        """
        Robustly extract JSON array from AI response
        Handles markdown, trailing text, and other issues
        """
        content = content.strip()
        
        # Remove markdown code blocks
        if content.startswith('```'):
            lines = content.split('\n')
            content = '\n'.join(lines[1:-1]) if len(lines) > 2 else content
            content = content.replace('```json', '').replace('```', '').strip()
        
        # Find the first '[' and last ']' to extract just the array
        start = content.find('[')
        if start == -1:
            return None
        
        # Count brackets to find matching close bracket
        bracket_count = 0
        end = -1
        for i in range(start, len(content)):
            if content[i] == '[':
                bracket_count += 1
            elif content[i] == ']':
                bracket_count -= 1
                if bracket_count == 0:
                    end = i + 1
                    break
        
        if end == -1:
            return None
        
        json_str = content[start:end]
        
        try:
            data = json.loads(json_str)
            if isinstance(data, list):
                return data
            return None
        except json.JSONDecodeError:
            return None
    
    def generate_data_with_openrouter(self, entity_type: str, count: int, 
                                     existing_ids: Optional[Dict] = None) -> List[Dict]:
        """
        Generate synthetic data using OpenRouter API
        
        Args:
            entity_type: Entity type to generate
            count: Number of records to generate
            existing_ids: Dict of existing IDs for relationships
            
        Returns:
            list: Generated records
        """
        schema = self.get_entity_schema(entity_type)
        
        # Special handling for Contacts with account info
        if entity_type == 'Contact' and existing_ids and 'accounts_info' in existing_ids:
            accounts_info = existing_ids['accounts_info']
            account_table = "Available Accounts (ID -> Name -> Email Domain):\n"
            for acc_id, acc_data in list(accounts_info.items())[:30]:
                account_table += f"  {acc_id} â†’ {acc_data['name']} â†’ {acc_data['domain']}\n"
            if len(accounts_info) > 30:
                account_table += f"  ... and {len(accounts_info) - 30} more accounts\n"
            
            sample_id = list(accounts_info.keys())[0] if accounts_info else 'SAMPLE-ID'
            sample_domain = accounts_info[sample_id]['domain'] if accounts_info else 'example.com'
            
            prompt = f"""Generate {count} realistic Contact records for a CRM system.

Schema for Contact:
{json.dumps(schema, indent=2)}

{account_table}

CRITICAL REQUIREMENTS - MUST FOLLOW:
1. EVERY Contact MUST include "accountId" field with an ID from the account table above
2. The email MUST match the domain for that account
3. Distribute contacts across different accounts
4. Email format: firstname.lastname@accountDomain (lowercase)
5. Phone format: +1-XXX-XXX-XXXX with varied area codes

MANDATORY FIELD: "accountId"
- This field is REQUIRED for every contact
- Must be one of the IDs from the account table above

EXAMPLE RECORD FORMAT:
{{
  "firstName": "John",
  "lastName": "Smith",
  "accountId": "{sample_id}",
  "emailAddress": "john.smith@{sample_domain}",
  "phoneNumber": "+1-415-555-0123"
}}

Return ONLY a valid JSON array of {count} contacts. Each contact MUST have accountId field. No markdown."""
        
        # Special handling for Opportunities with account info
        elif entity_type == 'Opportunity' and existing_ids and 'accounts_info' in existing_ids:
            accounts_info = existing_ids['accounts_info']
            account_table = "Available Accounts (ID -> Name):\n"
            for acc_id, acc_data in list(accounts_info.items())[:30]:
                account_table += f"  {acc_id} â†’ {acc_data['name']}\n"
            if len(accounts_info) > 30:
                account_table += f"  ... and {len(accounts_info) - 30} more accounts\n"
            
            sample_id = list(accounts_info.keys())[0] if accounts_info else 'SAMPLE-ID'
            sample_name = accounts_info[sample_id]['name'] if accounts_info else 'Example Corp'
            
            prompt = f"""Generate {count} realistic Opportunity records for a CRM system.

Schema for Opportunity:
{json.dumps(schema, indent=2)}

{account_table}

CRITICAL REQUIREMENTS:
1. EVERY Opportunity MUST include "accountId" field with an ID from the table above
2. The opportunity name MUST be relevant to the company it's linked to
3. Generate realistic deal names based on the company's likely business
4. Use realistic amounts ($5,000 to $500,000)
5. Vary the stages across opportunities
6. Dates format: YYYY-MM-DD

EXAMPLES OF GOOD OPPORTUNITY NAMES:
- Tech company â†’ "Enterprise Software License", "Cloud Migration Project", "API Integration Deal"
- Manufacturing â†’ "Equipment Upgrade", "Supply Chain Optimization", "Factory Automation"
- Consulting â†’ "Strategic Advisory Contract", "Digital Transformation", "Process Improvement"
- Retail â†’ "Store Expansion", "E-commerce Platform", "Inventory System Upgrade"

EXAMPLE RECORD:
{{
  "name": "Enterprise Software License Deal",
  "accountId": "{sample_id}",
  "amount": 125000,
  "stage": "Proposal",
  "closeDate": "2025-12-31"
}}

Return ONLY a valid JSON array. Each opportunity MUST have accountId. No markdown."""
        
        else:
            # Standard prompt for Accounts and Leads
            prompt = f"""Generate {count} realistic {entity_type} records for a CRM system.

Schema for {entity_type}:
{json.dumps(schema, indent=2)}

Requirements:
1. Generate diverse, realistic data with real-sounding company names, person names, addresses
2. For enum fields, ONLY use the exact specified options - no other values
3. For required fields, always provide a value
4. Use proper formats:
   - Dates: YYYY-MM-DD
   - Numbers: numeric values only
   - URLs: start with http:// or https://

CRITICAL - Phone Numbers:
- Use realistic formats with varied numbers ex: +1-202-837-0147, +1-415-230-0923, +1-312-118-0856
- Vary area codes: 202, 415, 312, 617, 213, 305, 718, 206, 646, 512, 404, 303, etc.
- Make all digits random and unique - avoid repetitive patterns"""

            # Add special instructions for Accounts
            if entity_type == 'Account':
                prompt += """

CRITICAL INSTRUCTION - YOU MUST GENERATE EXACTLY {count} RECORDS:
- I need EXACTLY {count} complete, unique Account records in your response
- Do not generate fewer than {count} records
- Each record must be completely different from the others

CRITICAL - Company Names (for Accounts):
- Create BRANDED company names with MAXIMUM VARIETY
- NEVER reuse these names: Quantum Dynamics, TechVision, Silverline, Nexus, Catalyst, Meridian
- Use combinations of:
  * Adjectives: Summit, Apex, Prime, Elite, Nova, Stellar, Pinnacle, Zenith, Alpha, Omega
  * Nouns: Forge, Bridge, Wave, Point, Edge, Core, Peak, Link, Hub, Network
  * Industries: Tech, Bio, Cyber, Data, Cloud, Digital, Smart, Green, Global, Micro
  * Suffixes: Inc, Corp, LLC, Co, Group, Solutions, Technologies, Systems, Partners, Industries
- Examples: Summit Forge Technologies, Nova Bridge Systems, Elite Data Partners, Prime Cyber Corp
- Generate creative combinations - be imaginative!
- Each name must be COMPLETELY UNIQUE - no repeats!

VARIETY REQUIREMENTS:
- Mix industries: Technology, Manufacturing, Healthcare, Finance, Retail, Consulting, etc.
- Vary company types: Customer, Partner, Investor, Reseller
- Use different US area codes: 202, 213, 312, 415, 512, 617, 646, 718, 305, 404, 503, 206
- Make websites match company names (lowercase, no spaces)
- Generate {count} DIFFERENT records"""

            prompt += """

CRITICAL - Email Addresses & Coherency:
- Contacts MUST have emails matching their company
- Derive email domain from the company name in the accountId
- Format: firstname.lastname@companydomain.com
- Examples:
  * Contact at "Acme Corporation" â†’ john.smith@acmecorp.com
  * Contact at "Tech Solutions Inc" â†’ sarah.jones@techsolutions.com
  * Contact at "Global Industries" â†’ mike.wilson@globalindustries.com
- Each email must be unique - no duplicates"""

            if existing_ids:
                prompt += f"\n\nCRITICAL - Relationships (accountId):\n- Available Account IDs: {json.dumps(existing_ids, indent=2)}"
                prompt += "\n- MUST use IDs from this list ONLY"
                prompt += "\n- Randomly distribute across accounts - don't cluster on just a few"
                prompt += "\n- Every Contact MUST have a valid accountId"
                prompt += "\n- Match the contact's email domain to their assigned account's company name"
            
            prompt += f"""

ABSOLUTE REQUIREMENT: Generate EXACTLY {count} complete records. Not less, not more.

Be creative and maximize variety:
- Use different combinations of words
- Vary all fields (names, emails, phones, addresses)
- Think of {count} completely unique organizations
- Add randomness to make each record distinct

Return ONLY a valid JSON array of {count} objects. No markdown, no explanations, just the JSON array.
Example format:
[
  {{"field1": "value1", "field2": "value2", ...}},
  {{"field1": "value1", "field2": "value2", ...}},
  ... ({count} total records)
]

Generate all {count} unique records now:"""
        
        print(f"\nðŸ¤– Generating {count} {entity_type} records via OpenRouter...")
        
        try:
            response = requests.post(
                'https://openrouter.ai/api/v1/chat/completions',
                headers={
                    'Authorization': f'Bearer {self.openrouter_api_key}',
                    'Content-Type': 'application/json',
                },
                json={
                    'model': 'anthropic/claude-4.5-sonnet',
                    'messages': [
                        {
                            'role': 'user',
                            'content': prompt
                        }
                    ],
                    'max_tokens': 16000
                }
            )
            
            if response.status_code == 200:
                result = response.json()
                content = result['choices'][0]['message']['content']
                
                # Try to extract JSON from the response
                content = content.strip()
                if content.startswith('```'):
                    # Remove markdown code blocks
                    lines = content.split('\n')
                    content = '\n'.join(lines[1:-1]) if len(lines) > 2 else content
                    content = content.replace('```json', '').replace('```', '').strip()
                
                # Parse the JSON
                # Parse the JSON with robust extraction
                data = self.extract_json_from_response(content)

                if not data:
                    print(f"  âœ— Failed to extract valid JSON array")
                    print(f"    Content preview: {content[:300]}...")
                    return []
                                
                print(f"  âœ“ Successfully generated {len(data)} records")
                return data
            else:
                print(f"  âœ— OpenRouter API error: {response.status_code}")
                print(f"    Response: {response.text}")
                return []
                
        except json.JSONDecodeError as e:
            print(f"  âœ— Failed to parse JSON from OpenRouter response: {e}")
            print(f"    Content: {content[:200]}...")
            return []
        except Exception as e:
            print(f"  âœ— Error calling OpenRouter: {e}")
            return []
    
    def insert_record(self, entity_type: str, data: Dict) -> Optional[str]:
        """
        Insert a single record into EspoCRM
        
        Args:
            entity_type: Entity type
            data: Record data
            
        Returns:
            str: Created record ID or None
        """
        try:
            response = self.espocrm_session.post(
                f"{self.espocrm_api_url}/{entity_type}",
                json=data
            )
            
            if response.status_code == 200:
                result = response.json()
                return result.get('id')
            else:
                print(f"    âœ— Failed to insert {entity_type}: {response.status_code}")
                if response.text:
                    print(f"      Error: {response.text[:200]}")
                return None
                
        except Exception as e:
            print(f"    âœ— Error inserting {entity_type}: {e}")
            return None
    
    def insert_batch(self, entity_type: str, records: List[Dict]) -> List[str]:
        """
        Insert multiple records and return their IDs
        
        Args:
            entity_type: Entity type
            records: List of records to insert
            
        Returns:
            list: List of created IDs
        """
        if not records:
            print(f"\nâš ï¸  No {entity_type} records to insert (generation failed)")
            return []
        
        print(f"\nðŸ“ Inserting {len(records)} {entity_type} records into EspoCRM...")
        
        created_ids = []
        
        for i, record in enumerate(records, 1):
            record_id = self.insert_record(entity_type, record)
            
            if record_id:
                created_ids.append(record_id)
                if i % 10 == 0:
                    print(f"  Progress: {i}/{len(records)} records inserted")
            
            # Small delay to avoid overwhelming the API
            time.sleep(0.1)
        
        print(f"  âœ“ Successfully inserted {len(created_ids)}/{len(records)} records")
        return created_ids
    
    def generate_and_insert_all(self, 
                                account_count: int = 100,
                                contact_count: int = 400,
                                lead_count: int = 100,
                                opportunity_count: int = 200):
        """
        Complete pipeline: Generate and insert all data
        
        Args:
            account_count: Number of accounts to generate
            contact_count: Number of contacts to generate
            lead_count: Number of leads to generate
            opportunity_count: Number of opportunities to generate
        """
        print("=" * 70)
        print("EspoCRM Synthetic Data Generation Pipeline")
        print("=" * 70)
        print(f"\nðŸ“Š Configuration:")
        print(f"  Accounts:      {account_count}")
        print(f"  Contacts:      {contact_count}")
        print(f"  Leads:         {lead_count}")
        print(f"  Opportunities: {opportunity_count}")
        print(f"  Batch Size:    {self.generation_batch_size}")
        print(f"  Max Retries:   {self.max_retries}")
        
        # Step 1: Generate Accounts
        print("\n" + "=" * 70)
        print("STEP 1: Generating Accounts")
        print("=" * 70)
        
        account_ids = self._generate_in_batches('Account', account_count)
        
        if not account_ids:
            print("\nâŒ Failed to generate accounts. Stopping pipeline.")
            return
        
        # Step 1.5: Fetch account data for email coherency
        print("\n" + "=" * 70)
        print("STEP 1.5: Fetching Account Data for Email Coherency")
        print("=" * 70)
        
        accounts_map = self.fetch_accounts_data(account_ids)
        
        # Build account info with derived domains
        accounts_info = {}
        for acc_id, acc_data in accounts_map.items():
            name = acc_data.get('name', 'Unknown Company')
            domain = self.derive_email_domain(name)
            accounts_info[acc_id] = {
                'name': name,
                'domain': domain
            }
        
        print(f"  âœ“ Prepared {len(accounts_info)} accounts with email domains")
        
        # Step 2: Generate Contacts (with proper email coherency)
        print("\n" + "=" * 70)
        print("STEP 2: Generating Contacts (with email coherency)")
        print("=" * 70)
        
        all_contact_ids = self._generate_in_batches(
            'Contact', 
            contact_count,
            existing_ids={'accounts_info': accounts_info}
        )
        
        # Step 3: Generate Leads
        print("\n" + "=" * 70)
        print("STEP 3: Generating Leads")
        print("=" * 70)
        
        lead_ids = self._generate_in_batches('Lead', lead_count)
        
        # Step 4: Generate Opportunities (linked to accounts)
        print("\n" + "=" * 70)
        print("STEP 4: Generating Opportunities")
        print("=" * 70)
        
        all_opp_ids = self._generate_in_batches(
            'Opportunity',
            opportunity_count,
            existing_ids={'accounts_info': accounts_info}
        )
        
        # Summary
        print("\n" + "=" * 70)
        print("GENERATION COMPLETE!")
        print("=" * 70)
        print(f"\nðŸ“Š Summary:")
        print(f"  Accounts:      {len(account_ids)}/{account_count} created")
        print(f"  Contacts:      {len(all_contact_ids)}/{contact_count} created")
        print(f"  Leads:         {len(lead_ids)}/{lead_count} created")
        print(f"  Opportunities: {len(all_opp_ids)}/{opportunity_count} created")
        print(f"\nâœ“ Total records created: {len(account_ids) + len(all_contact_ids) + len(lead_ids) + len(all_opp_ids)}")
        print(f"\nYou can now view your data at: {self.espocrm_url}")
    
    def _generate_in_batches(self, entity_type: str, total_count: int, 
                            existing_ids: Optional[Dict] = None) -> List[str]:
        """
        Generate records in batches with retry logic
        
        Args:
            entity_type: Type of entity to generate
            total_count: Total number of records to generate
            existing_ids: Optional relationship data
            
        Returns:
            list: All created record IDs
        """
        all_ids = []
        num_batches = math.ceil(total_count / self.generation_batch_size)
        
        for batch_num in range(num_batches):
            # Calculate batch size (last batch might be smaller)
            start_idx = batch_num * self.generation_batch_size
            batch_size = min(self.generation_batch_size, total_count - start_idx)
            
            print(f"\n  Batch {batch_num + 1}/{num_batches} ({batch_size} records):")
            
            # Try with retries
            records = []
            for attempt in range(self.max_retries):
                records = self.generate_data_with_openrouter(
                    entity_type, 
                    batch_size,
                    existing_ids
                )
                
                if records:  # Success!
                    break
                elif attempt < self.max_retries - 1:
                    print(f"  âš  Attempt {attempt + 1} failed, retrying...")
                else:
                    print(f"  âœ— All {self.max_retries} attempts failed, skipping batch")
            
            # Insert the batch
            if records:
                batch_ids = self.insert_batch(entity_type, records)
                all_ids.extend(batch_ids)
            else:
                print(f"  âš  Batch {batch_num + 1} skipped due to generation failure")
        
        return all_ids


def main():
    """
    Main entry point - CONFIGURE YOUR DATA GENERATION HERE
    """
    print("EspoCRM Synthetic Data Generator (Modular Configuration)")
    print("=" * 70)
    
    # ============================================================
    # CONFIGURATION - CHANGE THESE VALUES TO SUIT YOUR NEEDS
    # ============================================================
    
    # EspoCRM Connection
    ESPOCRM_URL = "http://localhost:8080"
    ESPOCRM_USERNAME = "admin"
    ESPOCRM_PASSWORD = "password"
    
    # OpenRouter API
    OPENROUTER_API_KEY = "YOUR_OPENROUTER_API_KEY_HERE"
    
    # Record Counts - EASILY CHANGE THESE!
    NUM_ACCOUNTS = 20        # Number of companies/accounts
    NUM_CONTACTS = 60        # Number of people (linked to accounts)
    NUM_LEADS = 100           # Number of unqualified leads
    NUM_OPPORTUNITIES = 0   # Number of sales opportunities (linked to accounts)
    
    # Generation Settings
    BATCH_SIZE = 50          # Records per API call (reduce if getting errors)
    MAX_RETRIES = 3           # Retry attempts for failed generations
    
    # ============================================================
    
    # Validate configuration
    if OPENROUTER_API_KEY == "YOUR_OPENROUTER_API_KEY_HERE":
        print("\nâŒ ERROR: Please set your OPENROUTER_API_KEY")
        print("   Get it from: https://openrouter.ai/keys")
        return
    
    # Initialize generator
    generator = EspoCRMDataGenerator(
        espocrm_url=ESPOCRM_URL,
        username=ESPOCRM_USERNAME,
        password=ESPOCRM_PASSWORD,
        openrouter_api_key=OPENROUTER_API_KEY,
        generation_batch_size=BATCH_SIZE,
        max_retries=MAX_RETRIES
    )
    
    # Run the complete pipeline with custom counts
    generator.generate_and_insert_all(
        account_count=NUM_ACCOUNTS,
        contact_count=NUM_CONTACTS,
        lead_count=NUM_LEADS,
        opportunity_count=NUM_OPPORTUNITIES
    )


if __name__ == "__main__":
    main()